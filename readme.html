<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="css/style.css" />
    <link rel="stylesheet" type="text/css" href="css/sh.css" />
    <title>
      README - 
    </title>
  </head>
  <body>
    <div class="fixed-wrapper">
      <div class="container">
        <div class="single">
          <div class="book normal">
            <h1 class="column align-center">
              <a href="index.html">Poly.shell Documentation</a>
            </h1>
            <p class="column align-center">
              A set of tools to make it easy to run jobs on different systems.
            </p>
            <div class="indent">
              <div class="indent-left-margin"></div>
              <div class="indent-content">
                <div id="toc"><h2>Table of Contents</h2><ul><li><a href="#poly.shell">Poly.shell</a><ul><li><a href="#distributed_shell_job_control_with_role_based_configuration">distributed shell job control with role based configuration</a></li><li><a href="#installation">Installation</a></li><li><a href="#coffeeScript">CoffeeScript</a></li><li><a href="#job_Scheduling">Job Scheduling</a></li><li><a href="#passwords">Passwords</a></li><li><a href="#scheduling">Scheduling</a></li></ul></li></ul><hr /></div>
<h1>Poly.shell</h1>

<h2 id="_distributed_shell_job_control_with_role_based_configuration">- distributed shell job control with role based configuration</h2>

<p>Poly.shell is primarily intended to administer server clusters, but it
can also be used to schedule other kinds of distributed computation, or
to just run simple shell commands.</p>

<p>Typical scenarios are to install new software, to monitor log files, to upload
new versions of web sites, and to verify that backup jobs have been completing
successfully.</p>

<p>The Capistrano and Vlad tools for Ruby on Rails are designed for these kind of
jobs. Poly.shell is a lower level tool but forms a good foundation for performing
standard routines such as deploying a new version of a web site pulled from
the latest source control branch.</p>

<p>The basic idea is to define a set of named jobs with actions that can run
in sequence, in parallel, or some variation thereof, on multiple local and
remote sites using role names to aid configuration.</p>

<p>Poly.shell can also be used as a convenient way to quickly run system
local shell commands:</p>

<pre><code>require('poly').shell().run("touch IWasHere");</code></pre>

<p>or to run commands on a single remote system:</p>

<pre><code>require('poly').shell('example.com').run("ls");</code></pre>

<h2 id="installation">Installation</h2>

<p>Download to some user local folder.</p>

<p>Enter folder and install using npm:</p>

<pre><code>npm install</code></pre>

<p>Or globally with npm 1.0.0:</p>

<pre><code>npm install -g</code></pre>

<p>Test that things are ok (see warning below):</p>

<pre><code>make test</code></pre>

<p>Note, the following tests run on a remote system example.com that is
supposed to be configured .ssh/config to match a suitable server.</p>

<p><strong>Don't use this on production systems!!! </strong></p>

<pre><code>make rtest</code></pre>

<p>Tests normally dump files in a local tmp dir that is cleaned with <code>make clean</code>.
Remote tests are not cleaned up, please inspect the test files in the <code>rtest</code> folder.</p>

<h2 id="coffeeScript">CoffeeScript</h2>

<p>Poly.shell is written primarily in CoffeeScript, but that shouldn't change anything.
If, for some reason (including debugging), a JavaScript version is needed,
a JavaScript only module can be created in sub-folder using:</p>

<pre><code>make js</code></pre>

<h2 id="job_Scheduling">Job Scheduling</h2>

<p>For more complex work, <code>jobs()</code> provides a job control
system to define named jobs that can be assembled in different schedules
and run on multiples sites:</p>

<pre><code>var jobs = require('poly').jobs();
var sites = jobs.sites;
var email = { send: function(to, title, body) { console.log "implement this"; } };

sites.add('local', { scripts: "~/repository/scripts", www: "~/stage/www" });
sites.add('appsvr-busy', ['app', 'primary'], { host: "app1.example.com" });
sites.add('appsvr-standby', 'app', { host: "app2.example.com" });

sites.update('app', {
  admin: "admin@example.com",
  adminAlert: function(title, body) { email.send(this.admin, title, body); };
});

jobs.add('deploy', 'app', function() {
  var status = {}
  var cb = this.async(); // hold next job until script completes
  this.shared[this.site.name] = status;
  this.shell.run("mydeployscript.sh", function(ec, capture) {
    status.ok = !ec;
    if(ec)
      this.site.adminAlert("deploy failed on " + site.name, capture());
    cb(); // don't fail here, next job should check status
  });

jobs.add('snapshot', 'app', function() {

  // Use this.shared to convey information to other jobs
  var status = this.shared[this.site.name] || {};

  // We might as well do the grunt work locally on the remote site
  // using shell scripts, or perhaps even Node.js poly.shell scripts.
  var scripts = ["scripts/myinit", "scripts/mybackup"];

  if(status.ok)
    scripts.shift();
  else
    scripts.push("scripts/myrollback");

  // hold next job until script completes by acquiring a async callback
  this.shell.run(scripts, this.async());
});

jobs.add('update', 'app', function() {
  env = sites.get('local');
  // run two concurrent rsyncs, but don't run next job until
  // both rsyncs are done (this.async() adds refcount)
  this.shell.upload(env.scripts, "scripts", this.async());
  this.shell.upload(env.www, "www", this.async());
});

jobs.add('prepare', 'local', function() {
  console.log("todo checkout data into this.site.scripts and this.site.www");
}

// prepare data for upload on local system
jobs.run('prepare', function() {
  // hold all jobs on all sites until we have prepared data for update
  // then run the following in sequence on each site,
  // but concurrently for all sites
  // ( in this example it will spawn 6 concurrent rsync commands )
  this.run(['update', 'snapshot', 'deploy', 'snapshot']);
});</code></pre>

<p>In the above script jobs execute in the default schedule
<code>site-sequential</code> meaning that jobs on different sites executes in
parallel, but in sequence on each site.</p>

<p>Sites are used to define a logical unit of configuration such that a
physical host can represent multiple sites - for example if a host
both operates a database and two different web domains.</p>

<p>Roles are used to name groups of sites in a server cluster. This makes
it easy to assign jobs to specific sites, and also to configure
multiple sites consistently with common settings.</p>

<p>Shells are can redirect output, so it is possible to integrate the job
runner with a web application framework such as <code>Express</code> for <code>Node.js</code>.</p>

<h2 id="passwords">Passwords</h2>

<p>Poly.shell does not support ssh password based account login. It is assumed that ssh
will use ssh keys without passwords, or with passwords managed by an external
agent such as <code>ssh-agent</code>.</p>

<p>Poly.shell does, however, support <code>sudo</code> password prompts after ssh login. In the
basic form a shell detects a sudo prompt and issues a silent prompt to the
user console.</p>

<p>Since many processes may target the same site, and many sites may have the
same admin password, it is convenient to cache a password across sites.</p>

<p>This works by creating a password cache object that is stored in all site
configurations that are supposed to share a <code>sudo</code> passwords.</p>

<p>Shells can detect when another shell is prompting for a password and wait for
the user to enter the password, and otherwise start a password prompt when no
valid password is cached.</p>

<h2 id="scheduling">Scheduling</h2>

<p>The Poly.shell job control scheduler is fairly simple. A schedule is an
array of job names which can be run in one the following modes:
<code>sequential</code>, <code>atomic</code>, <code>parallel</code>, or the default: <code>site-sequential</code>
where different jobs may run at the same time but each site will only
see one of the jobs at a time. These schedules can then be chained to
more complex scenarios if needed, and the same jobs can be reused in
different schedules. This model is somewhat similar to the various
Node.js async libraries like <code>seq</code>, <code>flow</code> and <code>async</code>, but with
role based job distribution, reporting, configuration, unique
identifiers, (remote) shell support, and password agents.</p>

<p>Poly.shell has no dependency resolver, but it is possible to use
Poly.shell inside a <code>Jakefile</code>, or in similar tools, or even in a
web framework like <code>Express</code>.</p>

<p>Locking primitives can be added, for example by using Node.js
EventEmitter objects in the shared context, or in site configurations
for example. The password cache and agent does something similar.
Locking provides a good algorithm for scheduling transactions.</p>
              </div>
              <div class="indent-right-margin"></div>
              <div class="clear"></div>
            </div>
          </div>
        </div>
      </div>
    </div><script type="text/javascript" src="js/sh_main.js">
</script><script type="text/javascript" src="js/sh_javascript.min.js">
</script><script type="text/javascript">
//<![CDATA[
    highlight(undefined, undefined, 'pre');
    //]]>
    </script>
  </body>
</html>
